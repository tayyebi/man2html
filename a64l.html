<!DOCTYPE html>
<html>
<head>
<style type="text/css">
body {background-color: black;}
pre {
	font-weight: normal;
	color: #bbb;
	white-space: -moz-pre-wrap;
	white-space: -o-pre-wrap;
	white-space: -pre-wrap;
	white-space: pre-wrap;
	word-wrap: break-word;
	overflow-wrap: break-word;
}
b {font-weight: normal}
b.BOLD {color: #fff}
b.ITA {font-style: italic}
b.UND {text-decoration: underline}
b.STR {text-decoration: line-through}
b.UNDSTR {text-decoration: underline line-through}
b.BLK {color: #000000}
b.RED {color: #aa0000}
b.GRN {color: #00aa00}
b.YEL {color: #aa5500}
b.BLU {color: #0000aa}
b.MAG {color: #aa00aa}
b.CYN {color: #00aaaa}
b.WHI {color: #aaaaaa}
b.HIK {color: #555555}
b.HIR {color: #ff5555}
b.HIG {color: #55ff55}
b.HIY {color: #ffff55}
b.HIB {color: #5555ff}
b.HIM {color: #ff55ff}
b.HIC {color: #55ffff}
b.HIW {color: #ffffff}
b.BBLK {background-color: #000000}
b.BRED {background-color: #aa0000}
b.BGRN {background-color: #00aa00}
b.BYEL {background-color: #aa5500}
b.BBLU {background-color: #0000aa}
b.BMAG {background-color: #aa00aa}
b.BCYN {background-color: #00aaaa}
b.BWHI {background-color: #aaaaaa}
</style>
</head>
<body>
<pre>a64l(3)                                               Library Functions Manual                                              a64l(3)

NAME
       a64l, l64a - convert between long and base-64

LIBRARY
       Standard C library (libc, -lc)

SYNOPSIS
       #include &lt;stdlib.h&gt;

       long a64l(const char *str64);
       char *l64a(long value);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       a64l(), l64a():
           _XOPEN_SOURCE &gt;= 500
               || /* glibc &gt;= 2.19: */ _DEFAULT_SOURCE
               || /* glibc &lt;= 2.19: */ _SVID_SOURCE

DESCRIPTION
       These functions provide a conversion between 32-bit long integers and little-endian base-64 ASCII strings (of length zero to
       six).  If the string used as argument for a64l() has length greater than six, only the first six bytes  are  used.   If  the
       type  long  has  more than 32 bits, then l64a() uses only the low order 32 bits of value, and a64l() sign-extends its 32-bit
       result.

       The 64 digits in the base-64 system are:

              '.'  represents a 0
              '/'  represents a 1
              0-9  represent  2-11
              A-Z  represent 12-37
              a-z  represent 38-63

       So 123 = 59*64^0 + 1*64^1 = "v/".

ATTRIBUTES
       For an explanation of the terms used in this section, see attributes(7).

       ┌─────────────────────────────────────────────────────────────────────────────────────┬───────────────┬─────────────────────┐
       │Interface                                                                            │ Attribute     │ Value               │
       ├─────────────────────────────────────────────────────────────────────────────────────┼───────────────┼─────────────────────┤
       │l64a()                                                                               │ Thread safety │ MT-Unsafe race:l64a │
       ├─────────────────────────────────────────────────────────────────────────────────────┼───────────────┼─────────────────────┤
       │a64l()                                                                               │ Thread safety │ MT-Safe             │
       └─────────────────────────────────────────────────────────────────────────────────────┴───────────────┴─────────────────────┘

STANDARDS
       POSIX.1-2001, POSIX.1-2008.

NOTES
       The value returned by l64a() may be a pointer to a static buffer, possibly overwritten by later calls.

       The behavior of l64a() is undefined when value is negative.  If value is zero, it returns an empty string.

       These functions are broken before glibc 2.2.5 (puts most significant digit first).

       This is not the encoding used by uuencode(1).

SEE ALSO
       uuencode(1), strtoul(3)

Linux man-pages 6.03                                         2023-02-05                                                     a64l(3)
</pre>
</body>
</html>
